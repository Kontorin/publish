### Тема 1: Системный подход и основы

#### 1.1. [[Чем отличается система от других объектов реального мира]]?
Система отличается от других объектов реального мира тем, что представляет собой иерархически организованную совокупность элементов, обладает интегративными свойствами и характеризуется наличием существенных связей между элементами.

#### 1.2. Модели триады системного подхода
Триада включает:
- Стратегическая модель – цель, смысл системы,
- Структурная модель – устройство, компоненты, данные, связи,
- Функциональная модель – поведение, алгоритмы, операции.

#### 1.3. Принципы структурного анализа
- **Разделяй и властвуй:** разбиение сложной системы на независимые, легко обозримые части.
- **Иерархическое упорядочивание:** организация частей в древовидные структуры.
- **Абстрагирование:** выделение только существенных характеристик системы на каждом уровне.
- **Графическое моделирование:** использование наглядных диаграмм для связи между аналитиком и заказчиком.
Два основных метода:
1. Декомпозиция – анализ системы путем исследования её частей,
2. Агрегирование – изучение системы через объединение элементов.

#### 1.4. Основные требования к моделям данных в сложных системах
Модель должна быть:
- Достаточно детальной и формализованной для написания программы,
- Компактной и наглядной для обсуждения,
- Независимой от особенностей реализации,
- Понятной большинству программистов.

#### 1.5. Отличие структурирования внешних и внутренних данных
Внешние данные структурируются для для долговременного, независимого и совместного использования данных разными программами, как правило записываются на менее быстрые, но более объёмные носители информации, т. е. в постоянную память на ПЗУ.
- Внешние данные структурируются в файлах и базах данных с моделей данных.

Внутренние же данные структурируются для эффективной работы алгоритмов внутри программы, и записываются в оперативную память. Для каждой задачи подбираются наиболее эффективные структуры данных. Определяется внутри программы.
- Внутренние данные структурируются в программе (массивы, записи, списки).


### Тема 2: Структуры данных (общие понятия)

#### 2.1. Основные отличительные особенности типов данных
Тип данных определяет:
- **Множество допустимых значений** — какие значения может принимать данный тип данных.
- **Множество операций**, которые могут выполняться над значениями этого типа.
- Структуру значения (скаляр, вектор и др.),
- Способ машинного представления.

#### 2.2. Основные требования к организации структур данных
- Эффективность выполнения операций,
- Экономия памяти,
- Простота реализации,
- Соответствие решаемой задаче.

#### 2.3. Преимущества динамических структур данных
- *Возможность изменения размера и структуры во время выполнения программы* — нет необходимости заранее задавать фиксированный размер.
- **Изменение логической последовательности элементов не требует перемещения данных в памяти** — достаточно изменить значения указателей.
- **Большая гибкость структуры данных** — возможность легко добавлять, удалять и перестраивать элементы во время работы программы.

#### 2.4. Что представляет собой типовая компонента (элемент) динамической структуры данных?
Запись, содержащая как минимум два поля:
1. Поле для данных (D),
2. Поле-указатель (P) на связанный элемент.

### Тема 3: Линейные динамические структуры
#### 3.1. Какие существуют динамические структуры данных?
- Однонаправленные (односвязные) списки,
- Двунаправленные (двусвязные) списки,
- Циклические (кольцевые) списки,
- Стеки (LIFO),
- Очереди (FIFO),
- Деки (двусторонние очереди),
- Бинарные деревья.

#### 3.2. Что такое кольцевой список, как он работает и как его сделать?

- Это список, у которого указатель последнего элемента ссылается на первый элемент.
- Создается путем замыкания указателя `Next` последнего элемента на голову списка.
- Для двусвязного кольцевого списка указатель `Prior` первого элемента указывает на последний.

#### 3.3. Какова роль указателей в динамических структурах данных?
Указатели обеспечивают существование динамических структур данных, связывая элементы, позволяя изменять размер структуры во время выполнения программы (динамическое выделение) и обеспечивая эффективные операции вставки, удаления и обхода.

- Обеспечение динамического выделения и освобождения памяти,
- Возможность изменения логической структуры без физического перемещения данных.

#### 3.4. Алгоритм вставки элемента в односвязный список
1. Выделить память под новый узел
2. Инициализировать поле с данными
3. Находится элемент списка, **после которого** выполняется вставка (предыдущий).
4. Установить его указатель `Next` на элемент, который будет следовать за ним.
5. Изменить указатель `Next` предыдущего элемента на новый элемент.
Вставка в односвязный список выполняется за счёт изменения указателей и имеет временную сложность **O(1)** (если позиция вставки известна).

#### 3.5. Основные функции стека (операции АТД «Стек»)
- `PUSH(S)` – добавление элемента на вершину,
- `POP(S)` – удаление элемента с вершины,
- `TOP(S)` – чтение элемента с вершины,
- `EMPTY(S)` – проверка на пустоту,
- MAKENULL(S) - создание пустого стека.
- CLEAR(S) — очистка стека, приведение его к пустому состоянию.

#### 3.6. Типовой набор операций для очереди (АТД «Очередь»)
- `ENQUEUE(Q)` – добавление элемента в конец,
- `DEQUEUE(Q)` – удаление элемента из начала,
- `FRONT(Q)` – чтение первого элемента,
- `EMPTY(Q)` – проверка на пустоту,
- `MAKENULL(Q)` – очистка очереди.
---
### Тема 4: Древовидные структуры

#### 4.1. Что такое дерево и его уровень?
- Дерево – иерархическая структура, состоящая из узлов, связанных отношениями «родитель-потомок».
- Уровень узла – расстояние от корня до этого узла (корень имеет уровень 0).

#### 4.2. Что такое упорядоченное дерево?
Дерево, у которого ветви (потомки каждого узла) упорядочены по определённому критерию (например, по значению ключа).

==Например по какому?==

#### 4.3. Какие основные принципы выделения элементов иерархической структуры (дерева)? 
- Существенность – выделение элементов, значимых для цели исследования,
- Однородность – элементы одного уровня имеют примерно одинаковую важность,
- Независимость – исключение взаимной зависимости элементов на одном уровне.

#### 4.4. Трансформация дерева в линейную структуру и обратно
Трансформация дерева в линейную структуру выполняется путём **обхода дерева** (прямого, симметричного или обратного) с последовательной записью вершин в линейный список или массив

Обратная трансформация (из линейной структуры в дерево) осуществляется путём **последовательного чтения элементов** и восстановления связей между узлами на основе порядка обхода и маркеров пустых вершин.

#### 4.5. Типовые операции для структуры данных «Дерево»

- Создание дерева,
- Вставка элемента,
- Удаление элемента,
- Поиск элемента,
- Обход дерева (прямой, симметричный, обратный),
- Проверка на пустоту,
- Удаление всего дерева.

#### 4.6. Последовательность действий при добавлении элемента в бинарное дерево
1. Проверяется, является ли дерево пустым; если пусто — добавляемый элемент становится **корнем дерева**
2. Если дерево не пусто, поиск позиции вставки начинается **с корневого узла**.
3. Значение добавляемого элемента сравнивается со значением текущего узла.
4. При меньшем значении переход осуществляется в **левое поддерево**, при большем — в **правое поддерево**.
5. Процесс сравнения и перехода повторяется рекурсивно или итеративно до достижения пустой ссылки.
6. Новый элемент вставляется на место пустой ссылки как **лист дерева**

#### 4.7. Алгоритм удаления элемента из бинарного дерева
1. Найти удаляемый узел.
2. Если нет потомков: удалить узел.
3. Если один потомок: заменить удаляемый узел на его потомка.
4. Если два потомка:
5. Найти замещающий узел (минимальный в правом поддереве или максимальный в левом),
6. Скопировать значение замещающего узла в удаляемый,
7. Рекурсивно удалить замещающий узел.

#### 4.8. Как производят поиск в древовидных структурах?
Путем обхода дерева и сравнения значений. Основные способы обхода:
- Прямой (pre-order): корень → левое поддерево → правое поддерево,
- Симметричный (in-order): левое поддерево → корень → правое поддерево,
- Обратный (post-order): левое поддерево → правое поддерево → корень.

---
### Тема 5: Абстрактные типы данных (АТД)

#### 5.1. Основные абстрактные типы данных (АТД)
- Вектор (массив),
- Список,
- Стек,
- Очередь,
- Дерево,
- Множество,
- Граф (ориентированный/неориентированный).

#### 5.2. Опишите словарь как структуру данных и чем отличается словарь от множества

**Словарь** — это структура данных, предназначенная для хранения набора элементов (обычно в виде **ключ–значение**) с поддержкой операций **вставки, удаления и поиска по ключу**

Отличие от множества: 
- словарь не поддерживает операции объединения, пересечения и разности
- ориентирован на эффективное управление отдельными элементами по ключу.

#### 5.3. Основные операции над множествами (АТД «Множество»)
- `UNION(A, B, C)` – объединение,
- `INTERSECTION(A, B, C)` – пересечение,
- `DIFFERENCE(A, B, C)` – разность,
- `MEMBER(X, A)` – проверка принадлежности элемента,
- `INSERT(X, A)` – вставка,
- `DELETE(X, A)` – удаление,
- `MAKENULL(A)` – создание пустого множества.
---
### Тема 6: Хеширование

#### 6.1. Что такое хеш-функция и её основные задачи
Хеш-функция - это функция, которая преобразует некоторый ключ произвольной длинны в хеш-код.
Основные задачи: обеспечение быстрого доступа к данным и минимизация коллизий.

#### 6.2. Какими свойствами должна обладать хеш-функция
- Простота вычисления,
- Равномерное распределение ключей по хеш-таблице,
- Минимизация коллизий,
- Отсутствие связи между ключами и адресами (функция не должна отображать логическую связь между значениями ключей  в связь между их адресами в таблице).

#### 6.3. Что представляет собой хеш-таблица
Это структура данных, представляющая ассоциативный массив, хранящий пару "ключ-значение". Доступ обеспечивается с помощью вычисления хеш-функции, формирующей индекс, при этом должны быть механизмы разрешения коллизий.
#### 6.4. В чем заключается метод закрытого хеширования?
Метод **закрытого хеширования** заключается в том, что **все элементы хранятся непосредственно в ячейках хеш-таблицы**, а при возникновении коллизии поиск свободной ячейки выполняется **по заданной последовательности пробирования** (линейное, квадратичное, двойное хеширование).

---
### Тема 7: Алгоритмы (общая теория)

#### 7.1. Какими свойствами должен обладать алгоритм решения задачи
«ДДКМР» — _Два Деда Купили МотоР_
- Дискретность – разбиение на отдельные шаги,
- Детерминированность – однозначность каждого шага,
- Конечность – завершимость за конечное число шагов,
- Массовость – применимость к разным исходным данным,
- Результативность – получение верного результата.

#### 7.2. Основные способы представления (записи) алгоритмов
- Словесное описание,
- Псевдокод,
- Графические блок-схемы,
- Программный код на языке программирования.

#### 7.3. Основные типы передачи управления в алгоритмах
- Линейное следование,
- Ветвление (условный переход),
- Цикл (повторение).
- Прерывание (Break/Continue)
- Вызов подпрограммы (рекурсия)

#### 7.4. Что такое О-нотация?
Это способ асимптотической оценки сложности алгоритма, он показывает как растут затраты ресурсов (памяти, времени) при увеличении входных данных.

#### 7.5. Что означает асимптотическая временная сложность при оценке алгоритма
Асимптотическая временная сложность — это характеристика алгоритма, показывающая, **как время выполнения растёт при увеличении размера входных данных n**, выражается через О-нотацию. Отражает предельное поведение функции при стремлении n к бесконечности.

#### 7.6. В чем заключается итерационный принцип создания алгоритмов
Это способ решения задачи, основанный на **многократном повторении** одной и той же совокупности действий (итерации), которая после определенного количества шагов приводит к желаемому результату.

#### 7.7. В чем заключается способ модульного составления алгоритмов
Модульное составление алгоритмов заключается в разбиении алгоритма на модули (подалгоритмы), с целью упрощения тестирования, разработки и понимания алгоритма.

---
### Тема 8: Методы проектирования алгоритмов
#### 8.1. В чем заключается метод декомпозиции при проектировании алгоритма?
Метод **декомпозиции** заключается в **разбиении исходной задачи на более простые подзадачи**, решение которых позволяет получить решение всей задачи; процесс продолжается до уровня элементарных операций или подпрограмм.

#### 8.2. Принцип работы динамического программирования
Задача разбивается на более простые взаимосвязанные подзадачи, каждая задача решается и её результат записывается для дальнейшего использования. Итоговое решение строится из результатов уже решённых подзадачах.

#### 8.3. В чем метод «жадного алгоритма»?
На каждом шаге выбирается локально оптимальное решение в надежде, что это приведёт к глобально оптимальному решению.

#### 8.4. Что такое поиск с возвратом в алгоритмах?
**Поиск с возвратом (backtracking)** — это метод алгоритмов, при котором решение строится **пошагово**, а при обнаружении невозможности продолжения выполняется **возврат к предыдущему шагу** и перебор альтернативных вариантов.

#### 8.5. Что представляет собой метод локального поиска
1. выбирают произвольное допустимое решение;
2. последовательно улучшают его локальными преобразованиями в заданном множестве, переходя к лучшему «соседнему» решению, пока улучшения возможны.

---
### Тема 9: Алгоритмы поиска
#### 9.1. Как работает последовательный (линейный) поиск данных?
Последовательно перебираются элементы и сравниваются с искомым значением, пока не найдётся совпадение или не будут перебраны все данные. Сложность O(n).

#### 9.2. Принцип бинарного поиска
**Бинарный поиск** заключается в том, что в **отсортированном массиве** искомый элемент последовательно сравнивается с **средним элементом**, после чего поиск продолжается **только в левой или правой половине массива**, уменьшая область поиска вдвое на каждом шаге (сложность O(log n)).

#### 9.3. Алгоритмы поиска подстроки в строке
Для поиска подстроки в тексте применяются следующие алгоритмы:
- **наивный (последовательный) поиск**;
- **алгоритм Кнута–Морриса–Пратта (КМП)**;
- **алгоритм Бойера–Мура**
- **алгоритм Рабина–Карпа**.

---
### Тема 10: Алгоритмы сортировки

#### 10.1. Какими параметрами можно оценить методы сортировки данных
Основные:
- временная сложность алгоритма
- кол-во используемой памяти
- устойчивость
- естественность
а так же:
- кол-во сравнений
- кол-во перестановок
#### 10.2. Основные алгоритмы внутренней сортировки
- Пирамидальная (HeapSort) – сложность O(n log n)
- Быстрая (QuickSort) – сложность O(n log n)
- Слиянием (MergeSort) – сложность O(n log n)
- Простые методы (пузырьком, вставками, выбором)

---
### 11. Дополнительные вопросы:

### 1. Абстрактный тип данных (АТД) — это
Модель типа данных, которая формально определяет множество объектов и набор операций над ними, полностью скрывая детали внутренней реализации. АТД предоставляет интерфейс для работы с данными, не зависящий от конкретного способа их хранения в памяти.

